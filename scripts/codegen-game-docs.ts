/**
 * game-docs â†’ TypeScript Codegen Bridge
 *
 * Reads YAML entity files from game-docs/soul-steel/ and generates
 * TypeScript `as const satisfies` catalogs for roblox-ts packages.
 *
 * Usage:
 *   npx tsx scripts/codegen-game-docs.ts
 *
 * Output:
 *   packages/combat-stats/src/generated/bestiary-catalog.ts
 *   packages/combat-stats/src/generated/ability-catalog.ts
 *   packages/combat-stats/src/generated/item-catalog.ts
 */

import { existsSync } from 'node:fs';
import { mkdir, readdir, readFile, writeFile } from 'node:fs/promises';
import { resolve } from 'node:path';
import { parse as parseYaml } from 'yaml';

// â”€â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const GAME_DOCS_ROOT =
  process.env.GAME_DOCS_ROOT ?? resolve(process.cwd(), '..', 'game-docs', 'soul-steel');

const OUTPUT_DIR = resolve(process.cwd(), 'packages', 'combat-stats', 'src', 'generated');

const HEADER = `/**
 * AUTO-GENERATED by scripts/codegen-game-docs.ts
 * DO NOT EDIT â€” regenerate with: npx tsx scripts/codegen-game-docs.ts
 *
 * Source: game-docs/soul-steel/
 */

`;

// â”€â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

interface BestiaryEntry {
  id: string;
  displayName: string;
  domain: string;
  faction?: string;
  level: number;
  rarity: string;
  baseAttributes: {
    strength: number;
    vitality: number;
    agility: number;
    intelligence: number;
    spirit: number;
    luck: number;
  };
  tags?: string[];
}

interface AbilityEntry {
  id: string;
  displayName: string;
  type: string;
  targetType: string;
  domain?: string;
  cooldown?: number;
  stats: {
    damage?: number;
    healing?: number;
    duration?: number;
    range?: number;
    cost?: number;
  };
  scaling?: Array<{
    attribute: string;
    multiplier: number;
    base: number;
  }>;
  tags?: string[];
}

interface ItemEntry {
  id: string;
  displayName: string;
  type: string;
  slot?: string;
  rarity: string;
  domain?: string;
  stats?: Record<string, number>;
  tags?: string[];
}

// â”€â”€â”€ YAML Reader â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function readYamlEntities<T>(category: string): Promise<T[]> {
  const dir = resolve(GAME_DOCS_ROOT, category);
  if (!existsSync(dir)) {
    console.warn(`  âš  Directory not found: ${dir}`);
    return [];
  }

  const files = await readdir(dir);
  const yamlFiles = files.filter((f) => f.endsWith('.yaml') && !f.startsWith('_'));
  const entries: T[] = [];

  for (const file of yamlFiles) {
    try {
      const raw = await readFile(resolve(dir, file), 'utf-8');
      const parsed = parseYaml(raw) as T;
      entries.push(parsed);
    } catch (err) {
      console.warn(`  âš  Failed to parse ${category}/${file}: ${err}`);
    }
  }

  return entries;
}

// â”€â”€â”€ Code Generators â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function generateBestiaryCatalog(entries: BestiaryEntry[]): string {
  if (entries.length === 0) return HEADER + '// No bestiary entries found.\nexport {};\n';

  const items = entries.map((e) => {
    const attrs = e.baseAttributes;
    return `  '${e.id}': {
    id: '${e.id}',
    displayName: '${e.displayName}',
    domain: '${e.domain}',
    faction: ${e.faction ? `'${e.faction}'` : 'undefined'},
    level: ${e.level},
    rarity: '${e.rarity}',
    baseAttributes: {
      strength: ${attrs.strength},
      vitality: ${attrs.vitality},
      agility: ${attrs.agility},
      intelligence: ${attrs.intelligence},
      spirit: ${attrs.spirit},
      luck: ${attrs.luck},
    },
    tags: [${(e.tags ?? []).map((t) => `'${t}'`).join(', ')}],
  }`;
  });

  return `${HEADER}export const BESTIARY_CATALOG = {
${items.join(',\n')},
} as const;

export type BestiaryId = keyof typeof BESTIARY_CATALOG;
`;
}

function generateAbilityCatalog(entries: AbilityEntry[]): string {
  if (entries.length === 0) return HEADER + '// No ability entries found.\nexport {};\n';

  const items = entries.map((e) => {
    const stats = e.stats ?? {};
    const scaling = (e.scaling ?? [])
      .map((s) => `{ attribute: '${s.attribute}', multiplier: ${s.multiplier}, base: ${s.base} }`)
      .join(', ');

    return `  '${e.id}': {
    id: '${e.id}',
    displayName: '${e.displayName}',
    type: '${e.type}',
    targetType: '${e.targetType}',
    domain: ${e.domain ? `'${e.domain}'` : 'undefined'},
    cooldown: ${e.cooldown ?? 0},
    stats: {
      damage: ${stats.damage ?? 0},
      healing: ${stats.healing ?? 0},
      duration: ${stats.duration ?? 0},
      range: ${stats.range ?? 0},
      cost: ${stats.cost ?? 0},
    },
    scaling: [${scaling}],
    tags: [${(e.tags ?? []).map((t) => `'${t}'`).join(', ')}],
  }`;
  });

  return `${HEADER}export const ABILITY_CATALOG = {
${items.join(',\n')},
} as const;

export type AbilityId = keyof typeof ABILITY_CATALOG;
`;
}

function generateItemCatalog(entries: ItemEntry[]): string {
  if (entries.length === 0) return HEADER + '// No item entries found.\nexport {};\n';

  const items = entries.map((e) => {
    const statsEntries = Object.entries(e.stats ?? {})
      .map(([k, v]) => `${k}: ${v}`)
      .join(', ');

    return `  '${e.id}': {
    id: '${e.id}',
    displayName: '${e.displayName}',
    type: '${e.type}',
    slot: ${e.slot ? `'${e.slot}'` : 'undefined'},
    rarity: '${e.rarity}',
    domain: ${e.domain ? `'${e.domain}'` : 'undefined'},
    stats: { ${statsEntries} },
    tags: [${(e.tags ?? []).map((t) => `'${t}'`).join(', ')}],
  }`;
  });

  return `${HEADER}export const ITEM_CATALOG = {
${items.join(',\n')},
} as const;

export type ItemId = keyof typeof ITEM_CATALOG;
`;
}

// â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function main() {
  console.log('ğŸ”„ game-docs â†’ TypeScript codegen');
  console.log(`  Source: ${GAME_DOCS_ROOT}`);
  console.log(`  Output: ${OUTPUT_DIR}`);

  // Ensure output dir exists
  await mkdir(OUTPUT_DIR, { recursive: true });

  // Read all entity categories
  const [bestiary, abilities, items] = await Promise.all([
    readYamlEntities<BestiaryEntry>('bestiary'),
    readYamlEntities<AbilityEntry>('abilities'),
    readYamlEntities<ItemEntry>('items'),
  ]);

  console.log(
    `  Found: ${bestiary.length} monsters, ${abilities.length} abilities, ${items.length} items`,
  );

  // Generate TypeScript files
  await Promise.all([
    writeFile(resolve(OUTPUT_DIR, 'bestiary-catalog.ts'), generateBestiaryCatalog(bestiary)),
    writeFile(resolve(OUTPUT_DIR, 'ability-catalog.ts'), generateAbilityCatalog(abilities)),
    writeFile(resolve(OUTPUT_DIR, 'item-catalog.ts'), generateItemCatalog(items)),
  ]);

  // Generate barrel export
  const barrel = `${HEADER}export { BESTIARY_CATALOG, type BestiaryId } from './bestiary-catalog';
export { ABILITY_CATALOG, type AbilityId } from './ability-catalog';
export { ITEM_CATALOG, type ItemId } from './item-catalog';
`;
  await writeFile(resolve(OUTPUT_DIR, 'index.ts'), barrel);

  console.log('âœ… Codegen complete');
}

main().catch((err) => {
  console.error('âŒ Codegen failed:', err);
  process.exit(1);
});
